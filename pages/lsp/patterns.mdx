import MainLayout from '~/components/layouts/main'

export const meta = {
  title: 'Шаблоны проектирования и приёмы рефакторинга'
}

export default ({ children }) => <MainLayout meta={meta}>{children}</MainLayout>

# Шаблоны проектирования и приёмы рефакторинга

Главная цель принципа — «исключить сюрпризы» в поведении объектов. Достигать этой цели помогают некоторые методы и шаблоны проектирования и приёмы рефакторинга.

## Контрактное программирование

[Контрактное программирование](https://ru.wikipedia.org/wiki/Контрактное_программирование) — это метод проектирования, при котором проектировщики чётко определяют и формализуют спецификации отношений между объектами.

Спецификации могут описывать интерфейсы методов, их пред- и постусловия, описание проверок и критерии соответствия. Такие спецификации называются контрактами.

В примере ниже интерфейс `Contract` описывает методы для проверки предусловия `require` и постусловия `ensure`. Класс `ContractAssert` реализует этот интерфейс, определяя, какие исключения следует сгенерировать при нарушении условий.

```ts
interface Contract {
  require(expression: boolean, msg?: string): void
  ensure(expression: boolean, msg?: string): void
}

class ContractAssert implements Contract {
  require(expression: boolean, msg?: string): void {
    if (!expression) throw new PreconditionException(msg)
  }

  ensure(expression: boolean, msg?: string): void {
    if (!expression) throw new PostconditionException(msg)
  }
}
```

Опишем исключения, наследуясь от стандартного `Error`. Класс `PreconditionException` отвечает за исключение при нарушении предусловия, `PostconditionException` — за нарушение постусловия.

```ts
class ContractException extends Error {
  constructor(msg?: string) {
    super(`contract error: ${msg}`)
  }
}

class PreconditionException extends ContractException {
  constructor(msg?: string) {
    super(`precondition failed, ${msg}`)
  }
}

class PostconditionException extends ContractException {
  constructor(msg?: string) {
    super(`postcondition failed, ${msg}`)
  }
}
```

Теперь если нам потребуется написать сумматор, который работает только с чётными числами, то мы можем проверять пред- и постусловия через контакт:

```ts
class EvenNumbersSummator {
  contract: Contract

  // создаём контракт для проверки и записываем в this.contract
  constructor(contract: Contract = new ContractAssert()) {
    this.contract = contract
  }

  add(a: number, b: number): number {
    // перед работой метода проверяем все предусловия
    this.contract.require(a % 2 === 0, 'first arg is not even')
    this.contract.require(b % 2 === 0, 'second arg is not even')

    const result = a + b

    // перед тем, как вернуть результат проверяем постусловия
    this.contract.ensure(result % 2 === 0, 'result is not even')
    this.contract.ensure(result === a + b, 'result is not equal to expected')
    return result
  }
}
```

Теперь метод не начнёт свою работу, если какое-то из предусловий будет нарушено, как и не вернёт результат, если будет нарушено постусловие.

## Материалы к разделу

- [Контрактное программирование](https://ru.wikipedia.org/wiki/Контрактное_программирование)
- [Design by Contract lib, gitlab](https://gitlab.com/ex.xsoft.dev/orbios.dbc)
- [The Contract Pattern, Michel de Champlain, PDF](https://hillside.net/plop/plop97/Proceedings/dechamplain.pdf)

## Стратегия + Фабрика + Декоратор

https://softwareengineering.stackexchange.com/questions/178886/liskov-substitution-and-abstract-classes-strategy-pattern/178888
https://en.wikipedia.org/wiki/Strategy_pattern


## Строитель

## Наследование по поведению, extract class

https://dzone.com/articles/solid-liskov-substitution-principle

*[PDF]:Portable document format
