import MainLayout from '~/components/layouts/main'
import Figure from '~/components/Figure'

export const meta = {
  title: 'Антипаттерны'
}

export default ({ children }) => <MainLayout meta={meta}>{children}</MainLayout>

# Антипаттерны

Неправильная или неполная реализация некоторых шаблонов проектирования или приёмов, а также неправильная иерархия сущнотей могут нарушить LSP.

## Непредсказуемое изменение поведения

Допустим, мы делаем клон Медиума, где авторы будут публиковать статьи. Статья может находиться в разных состяниях, от которых зависит, что с ней можно делать. Например, удалённую статью удалить нельзя, а опубликованную — снова опубликовать.

<Figure>
  <img src='/static/lsp-violation.svg' />
  <figcaption>Схема доступных действий со статьёй в зависимости от её состояния</figcaption>
</Figure>

Для подобной задачи подходит шаблон [состояние](https://refactoring.guru/ru/design-patterns/state) — он позволяет менять поведение объектов в зависимости от их внутреннего состояния. Если он реализован правильно и полно, то LSP он не нарушит. Однако, реализация в примере ниже нарушает.

Допустим, статья описывается базовым классом `Article`:

```ts
enum ArticleStatus {
  Draft
  Published
  Deleted
}

class Article {
  status: ArticleStatus

  constructor() {/*...*/}
  edit() {/*...*/}
  delete() {/*...*/}
  restore() {/*...*/}
  unpublish() {/*...*/}

  publish(): void {
    this.status = ArticleStatus.Published
  }
}
```

Если опубликованная статья при попытке публикации выбрасывает исключение, _которое не было описано в базовом классе_, то [мы нарушаем LSP](https://www.codeproject.com/Articles/648987/Violating-Liskov-Substitution-Principle-LSP):

```ts
class Published extends Article {
  constructor() {
    super({ status: ArticleStatus.Published })
  }

  // упс!
  publish(): void {
    throw new Error('article is already published')
  }
}
```

Чтобы реализация шаблона не нарушала LSP, нам необходимо описать в базовом классе возможность выбросить исключение. Для этого мы введём метод, который будет определять, можно ли статью публиковать:

```ts
class ArticleException extends Error {/*...*/}

class Article {
  // ...

  protected canPublish(): boolean {
    return this.status !== ArticleStatus.Published
  }

  publish(): void {
    if (!this.canPublish()) throw new ArticleException()
    // ...
  }
}
```

Сейчас переопределение метода `publish` для опубликованной статьи не будет усиливать предусловия, поэтому это не нарушит LSP:

```ts
class ArticlePublishedException extends ArticleException {/*...*/}

class Published extends Article {
  // ...

  publish(): void {
    // ArticlePublishedException наследуется от ArticleException,
    // указанного в классе Article, поэтому здесь нарушения нет
    throw new ArticlePublishedException()
  }
}
```

## Вопросы
WIP

## Интерфейс, которому нельзя доверять

https://stackoverflow.com/questions/20861107/can-anyone-provide-an-example-of-the-liskov-substitution-principle-lsp-using-v

## Материалы к разделу
- [Состояние](https://refactoring.guru/ru/design-patterns/state)
- [Violating LSP](https://www.codeproject.com/Articles/648987/Violating-Liskov-Substitution-Principle-LSP)
- [Examples of LSP violation](https://stackoverflow.com/questions/20861107/can-anyone-provide-an-example-of-the-liskov-substitution-principle-lsp-using-v)
- [Common pitfalls and bad practices](https://medium.com/@ipapikas/solid-series-3-5-liskov-substitution-principle-c71500ce9d29)


https://softwareengineering.stackexchange.com/questions/181922/does-the-state-pattern-violate-liskov-substitution-principle

*[LSP]:Liskov Substitution Principle
