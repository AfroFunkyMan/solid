import MainLayout from '~/components/layouts/main'

export const meta = {
  title: 'В реальной жизни'
}

export default ({ children }) => <MainLayout meta={meta}>{children}</MainLayout>

# Примеры из реальной жизни

Принцип открытости-закрытости побуждает проектировать отношения между сущностями системы до того, как вы начнёте писать код. Это в свою очередь помогает выявлять ошибки проектирования на более ранних этапах.

Также OCP помогает отвязать модули друг от друга так, что при изменении требований количество модулей, которые необходимо обновить, становится минимальным.

## Инъекция зависимостей и тестирование

При тестировании модулей, которые зависят от других модулей, разработчики могут столкнуться с проблемой, когда необходимо создать экземпляры каждой из зависимостей.

Если модуль зависит от конкретной реализации другого модуля, то разработчикам придётся имитировать конкретную зависимость. Допустим, есть класс, который логирует время:

```ts
type Timestamp = number;

class TimeLogger {
  static currentTime(): Timestamp {
    return Date.now();
  }
}
```

Чтобы протестировать `currentTime`, необходимо создать глобальный [мок-объект](https://ru.wikipedia.org/wiki/Mock-объект) класса `Date`. Создание глобальных объектов и переменных при тестировании может привести к неправильной работе соседних тестов. (Например, если кто-то забыл сбросить `Date` после использования.)

Если же мы привяжем зависимость не через конкретный объект, а через интерфейс, то получим возможность подменять зависимость на лету. Этот паттерн называется [инъекция зависимостей](https://ru.wikipedia.org/wiki/Внедрение_зависимости) (DI).

```ts
type Timestamp = number

interface DateTime {
  now(): Timestamp
}

class TimeLogger {
  static currentTime(date: DateTime = Date): Timestamp {
    return date.now();
  }
}
```

Теперь при тетсировании мы можем указать мок-объект для `DateTime` локально. При этом нам не потребуется эмулировать работу класса `Date` полностью. Нам достаточно лишь предусмотреть метод `now`, работу которого мы и проверим.

Например, используя [Jest](https://jestjs.io):

```ts
describe('TimeLogger', () => {
  it('should return current time stamp', () => {
    const mock: DateTime = {
      now: () => 42
    }

    const result = TimeLogger.currentTime(mock)
    expect(result).toEqual(42)
  })
})
```

Если же нам важно проверить, вызвался ли правильный метод у зависимости, то DI снова сделает решение задачи проще:

```ts
describe('TimeLogger', () => {
  it('should call now method of argument object', () => {
    const mock: DateTime = {
      now: jest.fn()
    }

    const result = TimeLogger.currentTime(mock)
    expect(mock.now).toHaveBeenCalled()
  })
})
```

Такой подход удобен при [разработке через тестирование](https://bespoyasov.ru/ttt-tdd/) (TDD). Он позволяет продумать API модуля и заранее предусмотреть как организовать зависимости модулей друг от друга.

## Инъекция зависимостей и расширение функциональности

<!-- Тот же класс, но теперь мы хотим взять другой Date, чтобы настроить заранее часовой пояс -->

## Материалы к разделу
- [Инъекция зависимостей](https://ru.wikipedia.org/wiki/Внедрение_зависимости)
- [Мок-объект](https://ru.wikipedia.org/wiki/Mock-объект)
- [Разработка через тестирование](https://bespoyasov.ru/ttt-tdd/)
- [Jest](https://jestjs.io)

*[OCP]:Open-closed principle
*[TDD]:Test driven development
*[DI]:Dependency injection
*[API]:Application programming interface
