import MainLayout from '~/components/layouts/main'

export const meta = {
  title: 'В реальной жизни'
}

export default ({ children }) => <MainLayout meta={meta}>{children}</MainLayout>

# Примеры из реальной жизни

Принцип открытости-закрытости побуждает проектировать отношения между сущностями системы до того, как вы начнёте писать код. Это в свою очередь помогает выявлять ошибки проектирования на более ранних этапах.

Также OCP помогает отвязать модули друг от друга так, что при изменении требований количество модулей, которые необходимо обновить, становится минимальным.

## Инъекция зависимостей и тестирование

При тестировании модулей, которые зависят от других модулей, разработчики могут столкнуться с проблемой, когда необходимо создать экземпляры каждой из зависимостей.

Если модуль зависит от конкретной реализации другого модуля, то разработчикам придётся имитировать конкретную зависимость. Допустим, есть класс, который логирует время:

```ts
class StorageService {
  get(key: string): any {
    return JSON.parse(localStorage.getItem(key))
  }
}
```

Чтобы протестировать `get`, необходимо создать глобальный [мок-объект](https://ru.wikipedia.org/wiki/Mock-объект) `localStorage`. Создание глобальных объектов и переменных при тестировании может привести к неправильной работе соседних тестов. (Например, если кто-то забыл сбросить `localStorage` после использования.)

Если же мы привяжем зависимость не через конкретный объект, а через интерфейс, то получим возможность подменять зависимость на лету. Этот паттерн называется [инъекция зависимостей](https://ru.wikipedia.org/wiki/Внедрение_зависимости) (DI).

```ts
declare type JSONString = string

interface Storage {
  getItem(key: string): JSONString
}

interface StorageDependencies {
  storage: Storage
}

class StorageService {
  storage: Storage

  // здесь указываем, какие зависимости следует использовать
  // JSON тоже стоит внедрять подобным образом,
  // но для простоты примера берём в расчёт только localStorage
  constructor({ storage = localStorage }: StorageDependencies) {
    this.storage = storage
  }

  get(key: string): any {
    // используем зависимость через интерфейс
    return JSON.parse(this.storage.getItem(key))
  }
}
```

Теперь при тетсировании мы можем указать мок-объект для `Storage` локально. При этом нам не потребуется эмулировать работу объекта `localStorage` полностью. Нам достаточно лишь предусмотреть метод `getItem`, работу которого мы и проверим. Например, используя [Jest](https://jestjs.io):

```ts
describe('StorageService', () => {
  it('should return specified value', () => {
    const mock: Storage = {
      getItem: (key: string) => '42'
    }

    const service = new StorageService({storage: mock})
    expect(service.get('test key')).toEqual(42)
  })
})
```

Если же нам важно проверить, вызвался ли правильный метод у зависимости, то DI снова сделает решение задачи проще:

```ts
describe('StorageService', () => {
  it('should call now method of dependency object', () => {
    const mock: Storage = {
      getItem: jest.fn()
    }

    const service = new StorageService({storage: mock})
    service.get('test key')

    expect(mock.getItem).toHaveBeenCalled()
  })
})
```

Такой подход удобен при [разработке через тестирование](https://bespoyasov.ru/ttt-tdd/) (TDD). Он позволяет продумать API модуля и заранее предусмотреть как организовать зависимости модулей друг от друга.

## Инъекция зависимостей и расширение функциональности

<!-- Тот же класс, но теперь мы хотим взять другой Date, чтобы настроить заранее часовой пояс -->

## Материалы к разделу
- [Инъекция зависимостей](https://ru.wikipedia.org/wiki/Внедрение_зависимости)
- [Мок-объект](https://ru.wikipedia.org/wiki/Mock-объект)
- [Разработка через тестирование](https://bespoyasov.ru/ttt-tdd/)
- [Jest](https://jestjs.io)

*[OCP]:Open-closed principle
*[TDD]:Test driven development
*[DI]:Dependency injection
*[API]:Application programming interface
