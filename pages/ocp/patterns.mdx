import MainLayout from '~/components/layouts/main'

export const meta = {
  title: 'Шаблоны проектирования и приёмы рефакторинга'
}

export default ({ children }) => <MainLayout meta={meta}>{children}</MainLayout>

# Шаблоны проектирования и приёмы рефакторинга

Соблюдать принцип открытости-закрытости помогают несколько шаблонов проектирования и приёмов рефакторинга.

## Абстрактная фабрика

[Фабрика](https://github.com/kamranahmedse/design-patterns-for-humans/blob/master/README.md#-simple-factory) — это сущность которая создаёт другие сущности по заданным правилам, например, инстанциирует классы или создаёт объекты.

[Абстрактная фабрика](https://refactoring.guru/ru/design-patterns/abstract-factory) — это фабрика, которая создаёт фабрики.

Этот шаблон позволяет создавать сущности без привязки к конкретным классам — то есть без привязки к реализации. Это позволяет добавлять новые типы сущностей, изменяя минимально необходимое количество модулей.

Рассмотрим применение абстрактной фабрики на том же примере с отчётом, что [был у нас в разделе об SRP](/srp/in-ideal-world).

В этом примере работа для абстрактной фабрики — выбор класса, который будет заниматься форматированием.

```ts
// часть с интерфейсом Formatter и классами,
// имплементирующими его, остаётся такой же

// добавляется новый интерфейс, описывающий фабрику фабрик
interface FormatterFactory {
  createFormatter(data: ReportData): Formatter
}

// метод createFormatter возвращает абстрактный интерфейс,
// поэтому обе фабрики ниже взаимозаменяемы
class HtmlFormatterFactory implements FormatterFactory {
  createFormatter(data: ReportData) {
    return new HtmlFormatter(data)
  }
}

class TxtFormatterFactory implements FormatterFactory {
  createFormatter(data: ReportData) {
    return new TxtFormatter(data)
  }
}

// при конфигурации приложение выберет нужный тип фабрики и будет работать с ним;
// коду приложения при этом будет не важно, с какой фабрикой он будет работать,
// потому что он будет зависеть от интерфейсов, а не от конкретных классов
class AppConfigurator {
  reportType: ReportTypes

  constructor(reportType: ReportTypes) {
    this.reportType = reportType
  }

  configure(reportData: ReportData): FormatterFactory {
    if (this.reportType === ReportTypes.Html) {
      return new HtmlFormatterFactory(reportData)
    }
    else return new TxtFormatterFactory(reportData)
  }
}
```

## Вопросы
WIP

## Стратегия

В прошлом примере мы избавились от необходимости менять код форматеров при добавлении новых требований. Но вы могли заметить, что в методе `configure` класса `AppConfigurator` есть условие, которое проверяет тип формата для отчёта.

По-хорошему подобные условия [следует заменять](https://softwareengineering.stackexchange.com/a/302782) на динамический выбор нужных сущностей. С этим может помочь ещё один шаблон — [стратегия](https://github.com/kamranahmedse/design-patterns-for-humans/blob/master/README.md#-strategy).

Этот шаблон позволяет менять настройки, конфигурацию или алгоритм в зависимости от ситуации и требований. В нашем случае стратегии мы отадим выбор необходимой фабрики:

```ts
function formatterStrategy(reportType: ReportTypes): FormatterFactory {
  const formatters = {
    [ReportTypes.Html]: HtmlFormatterFactory,
    [ReportTypes.Txt]: TxtFormatterFactory
  }

  return new formatters[reportType]()
}
```

Теперь выбор фабрик стал динамическим, и при изменении требований нам потребуется только добавить новую сущность и обновить список фабрик.

## Вопросы
WIP

## Декоратор

[Декоратор](https://refactoring.guru/ru/design-patterns/decorator) — это шаблон, который заключается в создании обёрток с дополнительной функциональнстью для объектов. Такие обёртки позволяют не изменять сам объект, но при этом расширять его функциональность.

Отличие декоратора от наследования в возможности расширять функциональность динамически, без необходимости описывать каждый класс-наследник отдельно.

В примере мы создаём класс `BaseGreeting`, метод `greet` которого будет выводить строку с приветствием пользователя. Декоратор `GreetingWithUppercase` будет приводить строку с приветствием к верхнему регистру.

```ts
interface Greeting {
  username: string
  greet(): string
}

// базовая функциональность описывается в классе,
// который будет обёрнут с помощью декораторов
class BaseGreeting implements Greeting {
  username: string

  constructor(username: string) {
    this.username = username
  }

  greet = (): string => {
    return `Hello, ${this.username}!`
  }
}


// в интерфейсе декоратора указываем поле wrappee,
// это объект, функционльность которого мы будем расширять
interface GreetingDecorator {
  wrappee: Greeting
  greet(): string
}

class GreetingWithUppercase implements GreetingDecorator {
  wrappee: Greeting

  constructor(wrappee: Greeting) {
    this.wrappee = wrappee
  }

  greet = (): string => {
    // 1. используем базовое поведение
    const baseGreeting = this.wrappee.greet()
    // 2. расширяем его и
    // 3. убеждаемся, что тип возвращаемого значения
    //    совпадает с указанным в типе Greeting
    return baseGreeting.toUpperCase()
  }
}
```

Сама философия этого шаблона повторяет принцип открытости-закрытости — мы не меняем базовый класс, а добавляем сущности, которые содержат в себе изменения бизнес-требований.

## Обзёрвер

## Замена прямого наследования на полиморфизм и композицию

## Материалы к разделу
- [Фабрика](https://github.com/kamranahmedse/design-patterns-for-humans/blob/master/README.md#-simple-factory)
- [Абстрактная фабрика](https://refactoring.guru/ru/design-patterns/abstract-factory)
- [Стратегия](https://github.com/kamranahmedse/design-patterns-for-humans/blob/master/README.md#-strategy)
- [Фабричный метод и применение стратегии](https://sergeyzhuk.me/2018/01/25/factory-method-and-open-closed/)
- [Декоратор](https://refactoring.guru/ru/design-patterns/decorator)
- [Decorator and Factory, Colorado CS](https://www.cs.colorado.edu/~kena/classes/5448/f09/lectures/18-decoratorfactory.pdf)

*[OCP]:Open-closed principle
*[SRP]:Single responsibility principle
*[CS]:Computer science
