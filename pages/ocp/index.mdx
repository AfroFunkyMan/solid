import MainLayout from '~/components/layouts/main'
import Figure from '~/components/Figure'

export const meta = {
  title: 'Введение'
}

export default ({ children }) => <MainLayout meta={meta}>{children}</MainLayout>

# Введение

Проектируя систему, мы занимаемся моделированием, а значит решаем инженерную задачу. Мы строим гипотезу о том, каковы отношения между сущностями в этой системе.

Однако бизнес-требования не вечны, они могут (и будут) меняться. Хорошо спроектированная система способна пережить эти изменения, отразить в себе и продолжить функционировать.

Основная причина, по которой вносить изменения бывает трудно или дорого — когда небольшое изменение в одной части системы вызывает лавину изменений в других частях. Если грубо и утрировано: когда в программе для изменения цвета кнопки надо поправить 15 модулей, такая система спроектирована плохо.

Принцип открытости-закрытости (OCP) пытается исключить такую проблему в принципе. Он гласит, что модули должны быть открыты для расширения, но закрыты для изменения. Простыми словами — модули надо проектировать так, чтобы их нельзя было менять вовсе, а новая функциональность должна появляться лишь с помощью создания новых сущностей и композиции их со старыми.

Основная цель принципа — помочь разработать проект, устойчивый к изменениям, срок жизни которых превышает срок существования первой версии проекта.

Модули, которые удовлетворяют OCP:
- _открыты для расширения_ — их функциональность может быть дополнена с помощью других модулей, если изменятся требования;
- _закрыты для изменения_ — их код менять нельзя (можно лишь исправлять ошибки).

Конечно, всегда есть изменения, которые невозможно внести, не изменив код какого-то модуля — никакая система не может быть закрыта на 100%. Поэтому при проектировании важен стратегический подход. Необходимо определить, от каких именно изменений и какие именно модули вы хотите закрыть. Это решение следует принимать опираясь на опыт, а также знания предметной области и пользователей системы.

Нарушение принципа открытости-закрытости приводит к ситуациям, когда изменение в одном модуле вынуждает менять другие, связанные с ним. Это в свою очередь [нарушает SRP](/srp), потому что весь код, который меняется по какой-то одной причине, должен быть собран в одном модуле. (Разные модули — разные причины для изменения.)

Посмотрим на пример. На схеме ниже объект `Client` непосредственно связан с объектом `Server`. Если нам вдруг понадобится, чтобы `Client` мог работать с разными объектами `Server`, нам придётся поменять его код.
<Figure>
  <img src="/static/ocp-violation.svg" />
  <figcaption>Структура, нарушающая OCP</figcaption>
</Figure>

Чтобы решить эту проблему, необходимо связывать объекты не напрямую, а через абстракции. Если все объекты `Server` имплементируют интерфейс `Abstract Server`, то нам уже не придётся менять код объекта `Client` для замены одного объекта `Server` на другой.
<Figure>
  <img src="/static/ocp-resolve.svg" />
  <figcaption>Абстракция помогает развязать модули</figcaption>
</Figure>

## Коротко
Принцип открытости-закрытости:
- заставляет проектировать модули так, чтобы они делали только одну вещь и делали её хорошо;
- побуждает связывать сущности через абстракции (а не реализацию) там, где могут поменяться бизнес-требования;
- обращает внимание проектировщиков на места стыка и взаимодействие сущностей;
- позволяет сократить количество кода, который необходимо менять при изменении бизнес-требований;
- делает внесение изменений безопасным и относительно дешёвым.

## Материалы к разделу
- [Принцип открытости-закрытости](https://ru.wikipedia.org/wiki/Принцип_открытости/закрытости)
- [Open-closed principle, Duke CS](https://www2.cs.duke.edu/courses/fall07/cps108/papers/ocp.pdf)
- [Clarifying my use of the open/closed principle, Eric Elliott](https://medium.com/@_ericelliott/clarifying-my-use-of-the-open-closed-principle-de54f77342c3)
- [Научный метод](https://ru.wikipedia.org/wiki/Научный_метод)
- [Основы ТРИЗ](https://ru.wikibooks.org/wiki/Основы_ТРИЗ)

## Вопросы
WIP

*[OCP]:Open-closed principle
*[SRP]:Single responsibility principle
*[ТРИЗ]:Теория решения изобретательских задач
*[CS]:Computer science
