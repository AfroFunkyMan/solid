import MainLayout from '~/components/layouts/main'

export const meta = {
  title: 'Антипаттерны'
}

export default ({ children }) => <MainLayout meta={meta}>{children}</MainLayout>

# Антипаттерны

Существуют и антипаттерны, которые или сами нарушают SRP, или усложняют следование принципу.

## Божественный объект
[Божественный объект](https://ru.wikipedia.org/wiki/Божественный_объект) — это сущность, которая отвечает за слишком многое».

Проблема их в том, что внутри таких объектов скапливается неоправданно большое количество данных. Со временем может случиться, что никакое действие нельзя будет сделать без участия божественного объекта.

Это затрудняет рефакторинг, тестирование и внесение изолированных изменений в код.

## Синглтон
[Синглтон](https://ru.wikipedia.org/wiki/Одиночка_(шаблон_проектирования)) — это паттерн, при котором в приложении существует только один экземпляр какого-то класса. Существующий синглтон гарантирует, что все новые созданные объекты будут ссылаться на него.

С точки зрения SRP это смешение ответственностей. Потому что синглтон не только выполняет свою основную функцию, но ещё и проверяет, не существует ли уже созданных экземпляров.

Проблем у этого паттерна несколько:
- он глобален — когда нарушается инкапсуляция состояния, повышается вероятность непредсказуемых нежелательных изменений;
- он излишне имплицитен — трудно заранее понять, как себя поведёт объект в какой-то ситуации;
- он трудно тестируется — глобальный объект хранит большое количество данных и может находиться в большом количестве различных состояний, из-за чего модульные тесты могут показывать непредсказуемые результаты.

## Смешение архитектурных слоёв
[Паттерн MVC](https://ru.wikipedia.org/wiki/Model-View-Controller) подразумевает три сущности: модель, представление и контроллер. Модель отвечает за хранение данных; представление — за их отображение; контроллер — за преобразование и обработку.

Смешение слоёв — это неправильное распределение или размазывание ответственностей между слоями. Оно может приводить:
- к [разрастанию контроллера](https://gunnarpeipman.com/aspnet/why-to-avoid-fat-controllers/), что делает его код трудным для понимания;
- появлению логики внутри модели, что затрудняет переиспользование модели.

## Материалы к разделу
- [3 способа нарушить SRP](https://habr.com/ru/post/330142/)
- [Божественный объект](https://ru.wikipedia.org/wiki/Божественный_объект)
- [God object. Анализ сложных проектов](https://habr.com/ru/post/147834/)
- [Синглтон](https://ru.wikipedia.org/wiki/Одиночка_(шаблон_проектирования))
- [Паттерн MVC](https://ru.wikipedia.org/wiki/Model-View-Controller)
- [Why to avoid fat controllers](https://gunnarpeipman.com/aspnet/why-to-avoid-fat-controllers/)


## Вопросы
**Как именно божественный объект нарушает принцип единой ответственности?**

_Решает слишком много слабо-связанных друг с другом задач_

_Хранит внутри себя чрезмерно много данных о слабо-связанных сущностях_

Имеет неоправданно большие размер и количество методов (Это не является прямым нарушением принципа, основная проблема — в слишком большом количестве ответственностей, которые берёт на себя такой объект)

**В чём главная проблема синглтона с точки зрения SRP?**

Может находиться в большом количестве различных состояний, из-за чего модульные тесты могут показывать непредсказуемые результаты (Это следствие основной причины — смешения двух задач: основной задачи модуля и проверки существования созданных ранее экземпляров)

_Берёт на себя помимо основной задачи проверку существования созданных ранее экземпляров_

Глобален и излишне имплицитен; трудно заранее понять, как он себя поведёт в какой-то ситуации (Это следствие основной причины — смешения двух задач: основной и проверки существования созданных ранее экземпляров)

**Чем с точки зрения SRP главная проблема смешения архитектурных слоёв?**

_Это неправильное распределение задач и размазывание ответственностей между сущностями_

Оно ведёт к разрастанию контроллера и плохой тестируемости (Это следствие главной причины — смешения ответственностей между слоями)

Затрудняет переиспользование модели из-за появления логики внутри неё (Это следствие главной причины — смешения ответственностей между слоями)

*[SRP]:Single responsibility principle
*[MVC]:Model-view-controller
